import { createSlice, PayloadAction } from '@reduxjs/toolkit';
// import { createWrapper, HYDRATE } from 'next-redux-wrapper';
import {
  actionAddEmitMsg,
  actionAddUser,
  actionAddUserConversion,
  actionFetchMessages,
  actionFetchUserConversion,
  actionGetAllUser,
  actionUploadFile,
} from '../actions/authActions';

const initialState: any = {
  userInfo: {},
  userList: [],
  loading: {
    loadingUserInfo: false,
    loadingUserList: false,
    fileUploading: false,
  },
  error: { errorUserInfo: false, errorUserList: false, fileUploading: false },
  message: '',
  userConversionInfo: {},
  conversationInfo: {},
  fileUrl: null,
  activeUsers: [],
  UsersTypingList: [],

  selectedUser: {},
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    saveUserInfo: (state, action: PayloadAction<any>) => {
      state.userInfo = action.payload;
    },
    saveSelectedUser: (state, action: PayloadAction<any>) => {
      state.selectedUser = action.payload;
    },
    saveAllUsers: (state, action: PayloadAction<any>) => {
      state.userList = action.payload;
    },
    saveActiveUsers: (state, action: PayloadAction<any>) => {
      state.activeUsers = action.payload;
    },
    saveUserMessageSocket: (state, action: PayloadAction<any>) => {
      state.userConversionInfo.messages.push(action.payload);
    },
    saveUserTypingList: (state, action: PayloadAction<any>) => {
      state.userTypingList.push(action.payload);
    },
    removeUserTypingList: (state, action: PayloadAction<any>) => {
      state.userTypingList.filter((item: string) => item !== action.payload);
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    // [HYDRATE]: (state, action) => {
    //   return {
    //     ...state,
    //     ...action.payload.auth,
    //   };
    // },
    builder
      .addCase(actionAddUser.pending, (state) => {
        state.loadingUserInfo = true;
      })
      .addCase(
        actionAddUser.fulfilled,
        (state, { payload }: PayloadAction<any>) => {
          console.log('Payload state [userInfo]', payload);

          // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
          state.loadingUserInfo = false;
          state.userInfo = payload?.data?.user;
        },
      )
      .addCase(
        actionAddUser.rejected,
        (state, { payload: { message } }: PayloadAction<any>) => {
          state.loadingUserInfo = false;
          state.errorUserInfo = true;
          state.message = message;
        },
      );
    builder
      .addCase(actionGetAllUser.pending, (state) => {
        state.loadingUserList = true;
      })
      .addCase(
        actionGetAllUser.fulfilled,
        (state, { payload }: PayloadAction<any>) => {
          // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
          state.loadingUserList = false;
          state.userList = payload?.data?.users;
        },
      )
      .addCase(
        actionGetAllUser.rejected,
        (state, { payload }: PayloadAction<any>) => {
          state.loadingUserList = false;
          state.errorUserList = true;
          state.message = payload || '';
        },
      );
    builder
      .addCase(actionAddUserConversion.pending, (state) => {
        state.loadingUserConversion = true;
      })
      .addCase(actionAddUserConversion.fulfilled, (state) => {
        // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
        state.loadingUserConversion = false;
        // state.userConversion = payload?.data?.messages;
      })
      .addCase(
        actionAddUserConversion.rejected,
        (state, { payload }: PayloadAction<any>) => {
          state.loadingUserConversion = false;
          state.errorUserList = true;
          state.message = payload || '';
        },
      );
    builder
      .addCase(actionFetchUserConversion.pending, (state) => {
        state.loadingUserConversion = true;
      })
      .addCase(
        actionFetchUserConversion.fulfilled,
        (state, { payload }: PayloadAction<any>) => {
          // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
          state.loadingUserConversion = false;
          state.conversationInfo = payload?.data;
        },
      )
      .addCase(
        actionFetchUserConversion.rejected,
        (state, { payload }: PayloadAction<any>) => {
          state.loadingUserConversion = false;
          state.errorUserList = true;
          state.message = payload || '';
        },
      );
    builder
      .addCase(actionFetchMessages.pending, (state) => {
        state.loadingUserConversion = true;
      })
      .addCase(
        actionFetchMessages.fulfilled,
        (state, { payload }: PayloadAction<any>) => {
          // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
          state.loadingUserConversion = false;
          state.userConversionInfo = payload?.data;
        },
      )
      .addCase(
        actionFetchMessages.rejected,
        (state, { payload }: PayloadAction<any>) => {
          state.loadingUserConversion = false;
          state.errorUserList = true;
          state.message = payload || '';
        },
      );
    builder
      .addCase(actionAddEmitMsg.pending, (state) => {
        state.loadingUserConversion = true;
      })
      .addCase(
        actionAddEmitMsg.fulfilled,
        (state, { payload }: PayloadAction<any>) => {
          // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
          state.loadingUserConversion = false;
          state.userConversionInfo.messages.push(payload.data);
        },
      )
      .addCase(
        actionAddEmitMsg.rejected,
        (state, { payload }: PayloadAction<any>) => {
          state.loadingUserConversion = false;
          state.errorUserList = true;
          state.message = payload || '';
        },
      );
    builder
      .addCase(actionUploadFile.pending, (state) => {
        state.fileUploading = true;
      })
      .addCase(
        actionUploadFile.fulfilled,
        (state, { payload }: PayloadAction<any>) => {
          // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
          state.fileUploading = false;
          state.fileUrl = payload?.data;
        },
      )
      .addCase(
        actionUploadFile.rejected,
        (state, { payload }: PayloadAction<any>) => {
          state.fileUploading = false;
          state.fileUploading = true;
          state.message = payload || '';
        },
      );
  },
});

export const {
  saveUserInfo,
  saveSelectedUser,
  saveAllUsers,
  saveActiveUsers,
  saveUserMessageSocket,
} = authSlice.actions;

export default authSlice.reducer;
